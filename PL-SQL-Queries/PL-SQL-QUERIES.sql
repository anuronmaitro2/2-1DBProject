--pl/SQL QUERIES
--bill RELATED TRIGGR
--INSERTING IN BILL TRIGGER 
--1
CREATE OR REPLACE TRIGGER insert_bill_trigger
AFTER INSERT ON PRESCRIPTION
FOR EACH ROW
DECLARE
    v_bill_id NUMBER;
BEGIN
    -- Generate the next value from the SEQ_BILLID sequence
    SELECT SEQ_BILLID.NEXTVAL INTO v_bill_id FROM DUAL;

    -- Insert a new record into the BILL table
    INSERT INTO BILL (BILLID, PRESCRIPTIONID, TOTAL_COST)
    VALUES (v_bill_id, :NEW.PRESCRIPTIONID, 0); -- Assuming doctor fee and lab fee initially set to 0

END;
--2
--UPDATE TOTAL COST FOR DOCTORBILL INSERTION
CREATE OR REPLACE TRIGGER update_bill_total_cost_triggerdoctor
AFTER INSERT ON DOCTORBILL
FOR EACH ROW
BEGIN
    -- Update the TOTAL_COST in the BILL table
    UPDATE BILL
    SET TOTAL_COST = TOTAL_COST + :NEW.DOCTORCOST
    WHERE PRESCRIPTIONID = :NEW.PRESCRIPTIONID;
END;
--3 
--UPDATE TOTAL COST FOR LAB BILL INSERTION 
CREATE OR REPLACE TRIGGER update_bill_total_cost_lab_trigger
AFTER INSERT ON LABBILL
FOR EACH ROW
BEGIN
    -- Update the TOTAL_COST in the BILL table
    UPDATE BILL
    SET TOTAL_COST = TOTAL_COST + :NEW.Cost
    WHERE PRESCRIPTIONID = :NEW.PRESCRIPTIONID;
END;
--UPDATING THR BILLSTATUS WHEN PRESCRIPTION STATUS IS UPDATED
--4 
CREATE OR REPLACE TRIGGER update_bill_status_trigger
AFTER UPDATE OF PRESCRIPTION_STATUS ON PRESCRIPTION
FOR EACH ROW
BEGIN
    IF :NEW.PRESCRIPTION_STATUS = 'PAID' THEN
        -- Update the BILLSTATUS to 'PAID'
        UPDATE BILL
        SET BILLSTATUS = 'PAID'
        WHERE PRESCRIPTIONID = :NEW.PrescriptionID;
    END IF;
END;
--QUERY FROM ADMIN 
SELECT B.BILLID, D.FIRSTNAME || ' ' || D.LASTNAME AS DOCTORNAME, LT.TESTNAME AS LABTESTNAME, PT.FIRSTNAME || ' ' || PT.LASTNAME AS PATIENTNAME, B.TOTAL_COST,B.ISSUEDATE FROM BILL B JOIN PRESCRIPTION P ON B.PRESCRIPTIONID = P.PRESCRIPTIONID JOIN APPOINTMENT A ON P.APPOINTMENTID = A.APPOINTMENTID JOIN DOCTOR D ON A.DOCTORID = D.DOCTORID JOIN PATIENT PT ON A.PATIENTID = PT.PATIENT_ID LEFT JOIN (SELECT LB.PRESCRIPTIONID, LISTAGG(LT.TESTNAME, ', ') WITHIN GROUP (ORDER BY LT.LABTESTID) AS TESTNAME FROM  LABBILL LB JOIN LABTESTS LT ON LB.LABTESTID = LT.LABTESTID GROUP BY  LB.PRESCRIPTIONID) LT ON P.PRESCRIPTIONID = LT.PRESCRIPTIONID WHERE B.BILLSTATUS = 'NOT PAID' AND B.TOTAL_COST IS NOT NULL AND B.TOTAL_COST <>0;

--TABLE FOR PAID AND UNPAID MONEYS 
CREATE TABLE MONEYS (
    PAID NUMBER,
    UNPAID NUMBER
);
INSERT INTO MONEYS VALUES(0,0);

--5
--PROCEDURE FOR CALCULATING TOTAL PAID AMOUNT 
CREATE OR REPLACE PROCEDURE CALCULATE_UPDATE_TOTAL_PAID_AMOUNT
AS
    v_paid_amount NUMBER;
BEGIN
    -- Calculate total paid amount
    SELECT NVL(SUM(TOTAL_COST), 0) INTO v_paid_amount
    FROM BILL
    WHERE BILLSTATUS = 'PAID';

    -- Update the first row in MONEYS table
    UPDATE MONEYS SET PAID = v_paid_amount WHERE ROWNUM = 1;
END;
--6
--CALCULATING TOTAL UNPAID AMOINT 
CREATE OR REPLACE PROCEDURE CALCULATE_UPDATE_TOTAL_UNPAID_AMOUNT
AS
    v_unpaid_amount NUMBER;
BEGIN
    -- Calculate total unpaid amount
    SELECT NVL(SUM(TOTAL_COST), 0) INTO v_unpaid_amount
    FROM BILL
    WHERE BILLSTATUS = 'NOT PAID';

    -- Update the first row in MONEYS table
    UPDATE MONEYS SET UNPAID = v_unpaid_amount WHERE ROWNUM = 1;
END;

--7
--TRIGGER WHEN A PATIENT CHANGES THE DISEASE 
CREATE TABLE PATIENTPREVIOUSDISEASES (
  PATIENT_ID NUMBER ,
  DISEASE VARCHAR2(50),
  CONSTRAINT FK_PREVDISEASE FOREIGN KEY (PATIENT_ID) REFERENCES PATIENT (PATIENT_ID)
);
CREATE OR REPLACE TRIGGER PatientDiseaseUpdateTrigger
AFTER UPDATE OF DISEASE ON PATIENT
FOR EACH ROW
BEGIN
    -- Insert the previous disease into PATIENTPREVIOUSDISEASES table
    INSERT INTO PATIENTPREVIOUSDISEASES (PATIENT_ID, DISEASE)
    VALUES (:OLD.PATIENT_ID, :OLD.DISEASE);
END;
--8
--INSERTING INTO PRESCRIPTION WHEN APPOINTMENT IS APPROVED 
CREATE OR REPLACE TRIGGER AppointmentApprovedTrigger
AFTER UPDATE OF NOTES ON APPOINTMENT
FOR EACH ROW
WHEN (NEW.NOTES = 'APPROVED')
BEGIN
    INSERT INTO PRESCRIPTION (PrescriptionID, AppointmentID, PRESCRIPTION_STATUS, PRESCRIPTIONDATE)
    VALUES (SEQ_PRESCRIPTION_ID.NEXTVAL, :NEW.AppointmentID, 'UNPAID', SYSDATE);
END;
/


--9
--TO KNOW A CERTIFIC MEDICINES WAS GIVEN TO A PATIENT 
CREATE TABLE MEDICINEGIVENLOG(
MEDICINEID NUMBER,
PATIENTID NUMBER,
APPOINTMENTID NUMBER
);
CREATE OR REPLACE TRIGGER TRACKMEDICINE
FOR INSERT ON ALLMEDICINEPRESCRIBERMEDICINERELATION
COMPOUND TRIGGER

    -- Declare variables
    V_MEDICINEID NUMBER;
    V_PRESCRIBEDMEDICINEID NUMBER;
    V_PATIENTID NUMBER;
    V_APPOINTMENTID NUMBER;

    -- Before statement trigger
    BEFORE STATEMENT IS
    BEGIN
        -- Initialize variables before the statement
        V_MEDICINEID := NULL;
        V_PRESCRIBEDMEDICINEID := NULL;
        V_PATIENTID := NULL;
        V_APPOINTMENTID := NULL;
    END BEFORE STATEMENT;

    -- Row-level before trigger
    BEFORE EACH ROW IS
    BEGIN
        -- Assign values for each row
        V_MEDICINEID := :NEW.MEDICINEID;
        V_PRESCRIBEDMEDICINEID := :NEW.PRESCRIBEDMEDICINEID;
    END BEFORE EACH ROW;

    -- After statement trigger
    AFTER STATEMENT IS
    BEGIN
        -- Perform actions after the statement
        -- This is where you can execute the logic that requires data from the table
        FOR R IN (SELECT DISTINCT A.PATIENTID, A.APPOINTMENTID
                  FROM MEDICINES M
                  JOIN ALLMEDICINEPRESCRIBERMEDICINERELATION ALPRM ON M.MEDICINEID = V_MEDICINEID
                  JOIN PRESCRIBEDMEDICINE PR ON PR.PRESCRIBEDMEDICINEID = V_PRESCRIBEDMEDICINEID
                  JOIN PRESCRIPTION PS ON PR.PRESCRIPTIONID = PS.PRESCRIPTIONID
                  JOIN APPOINTMENT A ON A.APPOINTMENTID = PS.APPOINTMENTID) 
        LOOP
            -- Insert into MEDICINEGIVENLOG for each distinct patient and appointment
            INSERT INTO MEDICINEGIVENLOG VALUES(V_MEDICINEID, R.PATIENTID, R.APPOINTMENTID);
        END LOOP;
    END AFTER STATEMENT;

END TRACKMEDICINE;
--TESTING
INSERT INTO PRESCRIBEDMEDICINE VALUES(104,152,'Once in a 7 day and Continue');
INSERT INTO ALLMEDICINEPRESCRIBERMEDICINERELATION VALUES(104,2);
SELECT * FROM MEDICINEGIVENLOG;

--10
--TO KNOW WHICH LAB TEST GIVEN TO WHICH PATIENT 

CREATE TABLE GIVENLABTESTLOG(
	LABTESTID NUMBER,
	PATIENTID NUMBER,
	APPOINTMENTID NUMBER
	);
	
	CREATE OR REPLACE TRIGGER TRACKLABTEST
FOR INSERT ON PRESCRIBEDLABTESTALLLABTESTRELATION
COMPOUND TRIGGER

    -- Declare variables
    V_LABTESTID NUMBER;
    V_PRESCRIBEDLABTESTID NUMBER;

    BEFORE EACH ROW IS
    BEGIN
        V_LABTESTID := :NEW.LABTESTID;
        V_PRESCRIBEDLABTESTID := :NEW.PRESCRIBEDLABTESTID;
    END BEFORE EACH ROW;

    AFTER EACH ROW IS
    BEGIN
        FOR R IN (
            SELECT A.PATIENTID, A.APPOINTMENTID
            FROM PRESCRIBEDLABTEST PLT
						JOIN PRESCRIPTION PS ON PLT.PRESCRIPTIONID=PS.PRESCRIPTIONID
            JOIN APPOINTMENT A ON A.APPOINTMENTID = PS.APPOINTMENTID
            WHERE PLT.PRESCRIBEDLABTESTID = V_PRESCRIBEDLABTESTID
        ) LOOP
            INSERT INTO GIVENLABTESTLOG VALUES (V_LABTESTID, R.PATIENTID, R.APPOINTMENTID);
        END LOOP;
    END AFTER EACH ROW;

END TRACKLABTEST;

--TESTING 
INSERT INTO PRESCRIBEDLABTEST VALUES (63,148,'TEST PENDING');
INSERT INTO PRESCRIBEDLABTESTALLLABTESTRELATION VALUES (2,63);
SELECT * FROM GIVENLABTESTLOG;


--11
--PROCEDURE TO CALCULATE HOW MANY TIMES A MEDICINE HAS BEEN PRESCRIBED 

CREATE TABLE MEDICINECOUNT(
MEDICINENAME VARCHAR2(100),
PRESCRIBEDCOUNT NUMBER
);
CREATE OR REPLACE PROCEDURE FILL_MEDICINE_COUNT AS
BEGIN
    -- Delete all rows from MEDICINECOUNT table
    DELETE FROM MEDICINECOUNT;

    -- Insert new data into MEDICINECOUNT
    INSERT INTO MEDICINECOUNT (MEDICINENAME, PRESCRIBEDCOUNT)
    SELECT DISTINCT
        M.MedicineName,
        (
            SELECT COUNT(*)
            FROM ALLMEDICINEPRESCRIBERMEDICINERELATION AM
            JOIN PRESCRIBEDMEDICINE PM ON AM.PRESCRIBEDMEDICINEID = PM.PRESCRIBEDMEDICINEID
            WHERE AM.MedicineID = M.MedicineID
        ) AS PrescriptionCount
    FROM MEDICINES M;
    
    COMMIT;
END;

DECLARE
BEGIN
FILL_MEDICINE_COUNT;
END;

--CHECK 
SELECT * FROM MEDICINECOUNT;

--12 
--PROCEDURE TO CALCULATE HOW MANY TIMES A LAB TEST HAS BEEN PRESCRIBED 
CREATE TABLE  LOGLABTESTCOUNT(
TESTNAME VARCHAR2(100),
PRESCRIBEDCOUNT NUMBER
);

CREATE OR REPLACE PROCEDURE FILL_LABTEST_COUNT AS
BEGIN
    -- Delete all rows from LOGLABTESTCOUNT table
    DELETE FROM LOGLABTESTCOUNT;

    -- Insert new data into LOGLABTESTCOUNT
    INSERT INTO LOGLABTESTCOUNT (TESTNAME, PRESCRIBEDCOUNT)
    SELECT DISTINCT
        LT.TESTNAME,
        (
            SELECT COUNT(*)
            FROM PRESCRIBEDLABTESTALLLABTESTRELATION PLTR
            JOIN PRESCRIBEDLABTEST PLT ON PLTR.PRESCRIBEDLABTESTID = PLT.PRESCRIBEDLABTESTID
            WHERE PLTR.LABTESTID = LT.LABTESTID
        ) AS PrescriptionCount
    FROM LABTESTS LT;

    COMMIT;
END;

BEGIN
FILL_LABTEST_COUNT;
END;

SELECT * FROM LOGLABTESTCOUNT;

--13 
--COMPLETED LAB TEST GULO 
CREATE TABLE COMPLETEDLABTESTLOGCOUNT(
TESTNAME VARCHAR2(100),
COMPLETEDCOUNT NUMBER
);

CREATE OR REPLACE PROCEDURE FILL_COMPLETED_LABTEST_COUNT AS
BEGIN
    -- Delete all rows from COMPLETEDLABTESTLOGCOUNT table
    DELETE FROM COMPLETEDLABTESTLOGCOUNT;

    -- Insert new data into COMPLETEDLABTESTLOGCOUNT
    INSERT INTO COMPLETEDLABTESTLOGCOUNT (TESTNAME, COMPLETEDCOUNT)
    SELECT DISTINCT
        LT.TESTNAME,
        (
            SELECT COUNT(*)
            FROM RESULT R
            JOIN PRESCRIBEDLABTESTALLLABTESTRELATION PLTR ON R.PRESCRIBEDLABTESTID = PLTR.PRESCRIBEDLABTESTID
            JOIN LABTESTS LT2 ON PLTR.LABTESTID = LT2.LABTESTID
            WHERE LT.TESTNAME = LT2.TESTNAME AND R.RESULTDATE IS NOT NULL
        ) AS CompletedCount
    FROM LABTESTS LT;

    COMMIT;
END;
/

BEGIN
FILL_COMPLETED_LABTEST_COUNT;
END;

SELECT * FROM COMPLETEDLABTESTLOGCOUNT;

--14
--APPOINTMENT INFO of PATIENT
CREATE TABLE APPOINTMENTINFOLOG(
PatientName VARCHAR2(100),
DoctorName VARCHAR2(100),
NumberOfAppointments NUMBER,
TotalCost NUMBER
);

CREATE OR REPLACE TRIGGER MAITRO.PrescriptionInsertTrigger
AFTER UPDATE OF NOTES ON APPOINTMENT
FOR EACH ROW
WHEN (NEW.NOTES = 'APPROVED')
DECLARE
    v_DoctorName VARCHAR2(100);
    v_patientName VARCHAR2(100);
    v_Count NUMBER;
BEGIN
    -- Get Doctor Name from the DOCTOR table based on DoctorId in the prescription
    SELECT FirstName || ' ' || LastName
    INTO v_DoctorName
    FROM DOCTOR
    WHERE DoctorId = :NEW.DoctorId;

    -- Get the Patient Name based on PatientId in the appointment
    SELECT FIRSTNAME || ' '||LASTNAME
    INTO v_patientName
    FROM PATIENT
    WHERE PATIENT_ID = :NEW.PatientID;

    -- Check if the Doctor exists in the APPOINTMENT INFO table
    SELECT COUNT(*)
    INTO v_Count
    FROM APPOINTMENTINFOLOG
    WHERE DoctorName = v_DoctorName AND PatientName = v_patientName;

    IF v_Count = 0 THEN
        -- If the Doctor doesn't exist, insert a new row
        INSERT INTO APPOINTMENTINFOLOG (PatientName, DoctorName, NumberOfAppointments, TotalCost)
        VALUES (v_patientName, v_DoctorName, 1, 0);
    ELSE
        -- If the Doctor exists, update the existing row
        UPDATE APPOINTMENTINFOLOG
        SET NumberOfAppointments = NumberOfAppointments + 1
        WHERE DoctorName = v_DoctorName AND PatientName = v_patientName;
    END IF;
END;

CREATE OR REPLACE TRIGGER DoctorBillInsertTrigger
AFTER INSERT ON DOCTORBILL
FOR EACH ROW
BEGIN
    -- Update the APPOINTMENT INFO table with the total cost of the Doctor's appointments
    UPDATE APPOINTMENTINFOLOG
    SET TotalCost = TotalCost + :NEW.DOCTORCOST
    WHERE DoctorName = (
        SELECT FirstName || ' ' || LastName
        FROM DOCTOR
        WHERE DoctorId = :NEW.DoctorId
    );
END;
/
--TEST 
UPDATE APPOINTMENT SET NOTES='APPROVED' WHERE APPOINTMENTID=169;
SELECT * FROM APPOINTMENTINFOLOG;

--15 
--UPDATING COST 
CREATE OR REPLACE TRIGGER DoctorBillInsertTrigger
FOR INSERT ON DOCTORBILL
COMPOUND TRIGGER

    -- Declare variables here
    v_PatientName VARCHAR2(100);

BEFORE EACH ROW IS
    -- Initialization before each row
    v_DoctorId DOCTOR.DOCTORID%TYPE;
BEGIN
    -- Get the DoctorId from the associated Prescription
    SELECT DoctorId INTO v_DoctorId
    FROM PRESCRIPTION PR
    JOIN APPOINTMENT A ON PR.AppointmentID = A.AppointmentID
    WHERE PR.PrescriptionID = :NEW.PRESCRIPTIONID;

    -- Get the Patient Names from the associated Prescription using BULK COLLECT
    SELECT P.FirstName || ' ' || P.LastName
     INTO v_PatientName
    FROM APPOINTMENT A
    JOIN PATIENT P ON A.PatientID = P.PATIENT_ID
    JOIN PRESCRIPTION PR2 ON PR2.APPOINTMENTID = A.AppointmentID
    WHERE PR2.PrescriptionID = :NEW.PRESCRIPTIONID;

    -- Debug information
    --DBMS_OUTPUT.PUT_LINE('DoctorId: ' || v_DoctorId);
    -- Handle the scenario where multiple patients are associated with the same prescription
            UPDATE APPOINTMENTINFOLOG
            SET TotalCost = TotalCost + :NEW.DOCTORCOST
            WHERE DoctorName = (
                SELECT FirstName || ' ' || LastName
                FROM DOCTOR
                WHERE DoctorId = v_DoctorId
            )
            AND PatientName = v_PatientName;
END BEFORE EACH ROW;

END DoctorBillInsertTrigger;

--TEST 
SELECT * FROM APPOINTMENTINFOLOG;
INSERT INTO DOCTORBILL VALUES(22,161,5000);
INSERT INTO DOCTORBILL VALUES(24,161,6000);
INSERT INTO DOCTORBILL VALUES(25,161,6000);
INSERT INTO DOCTORBILL VALUES(26,161,6000);
INSERT INTO DOCTORBILL VALUES(27,161,6000);
INSERT INTO DOCTORBILL VALUES(28,161,6000);

--16 
--procedure to calculate doctor and their earning so far 
CREATE TABLE DOCTOREARNING(
DOCTORNAME VARCHAR2(100),
EARNING NUMBER
);
CREATE OR REPLACE PROCEDURE CalculateDoctorEarnings AS
BEGIN
    -- Clear existing data in DOCTOREARNING table
    DELETE FROM DOCTOREARNING;

    -- Insert new data based on doctor earnings
    INSERT INTO DOCTOREARNING (DOCTORNAME, EARNING)
SELECT         D.FirstName || ' ' || D.LastName AS DoctorName,
        NVL(SUM(DB.DOCTORCOST), 0) AS Earning
FROM PRESCRIPTION P 
JOIN DOCTORBILL DB ON DB.PRESCRIPTIONID=P.PRESCRIPTIONID
JOIN APPOINTMENT A ON A.APPOINTMENTID=P.APPOINTMENTID
JOIN DOCTOR D ON D.DOCTORID=A.DOCTORID
WHERE P.PRESCRIPTION_STATUS='PAID' AND A.APPOINTMENTDATE BETWEEN SYSDATE-30 AND SYSDATE
GROUP BY A.DOCTORID,D.DOCTORID,D.FIRSTNAME,D.LASTNAME

    COMMIT;
END CalculateDoctorEarnings;

--17
CREATE TABLE MAXAPPOINTMENT(
DOCTORID NUMBER,
PATIENTNAME VARCHAR2(100),
NUMBEROFAPPOINTMENTS NUMBER
);
--for a doctor procedure  to find out which patient has took maximum APPOINTMENT with him,input doctor id,WORK FILL TABLE ROW
CREATE OR REPLACE PROCEDURE FindMaxAppointmentsForDoctor(p_DoctorId NUMBER) AS
    v_MaxAppointments NUMBER := NULL;
BEGIN
    -- Clear existing data in MAXAPPOINTMENT table for the specified doctor
    DELETE FROM MAXAPPOINTMENT ;

    -- Insert new data based on the maximum appointments for the specified doctor
    FOR rec IN (
        SELECT
            D.DOCTORID,
            P.FirstName || ' ' || P.LastName AS PATIENTNAME,
            COUNT(A.AppointmentID) AS NUMBEROFAPPOINTMENTS
        FROM
            DOCTOR D
        JOIN
            APPOINTMENT A ON D.DOCTORID = A.DOCTORID
        JOIN
            PATIENT P ON A.PATIENTID = P.PATIENT_ID
        WHERE
            D.DOCTORID = p_DoctorId
        GROUP BY
            D.DOCTORID, P.FirstName, P.LastName
        ORDER BY
            NUMBEROFAPPOINTMENTS DESC
    ) LOOP
        -- Insert only the rows with the maximum count into MAXAPPOINTMENT table
        IF v_MaxAppointments IS NULL OR rec.NUMBEROFAPPOINTMENTS = v_MaxAppointments THEN
            INSERT INTO MAXAPPOINTMENT (DOCTORID, PATIENTNAME, NUMBEROFAPPOINTMENTS)
            VALUES (rec.DOCTORID, rec.PATIENTNAME, rec.NUMBEROFAPPOINTMENTS);
        ELSE
            -- If the count is not equal to the maximum, break the loop
            EXIT;
        END IF;

        -- Update the maximum value after the first iteration
        IF v_MaxAppointments IS NULL THEN
            v_MaxAppointments := rec.NUMBEROFAPPOINTMENTS;
        END IF;
    END LOOP;

    COMMIT;
END FindMaxAppointmentsForDoctor;


BEGIN
FindMaxAppointmentsForDoctor(7);
END;
SELECT * FROM MAXAPPOINTMENT;

--18
CREATE TABLE MAXAPPOINTMENTPATIENT
(
	PATIENTNAME VARCHAR2(100),
	DOCTORNAME VARCHAR2(100),
	NUMBEROFAPPOINTMENTS NUMBER
);
--PROCEDURE TO FIND OUT WITH WHICH DOCTOR THE PATIENT HAS DONE MOST APPOINTMENT INPUT WILL BE PATIENT WORK WILL BE TO FILL THE TABLE 
CREATE OR REPLACE PROCEDURE MAITRO.FindMaxAppointmentsForPatient(p_PatientId NUMBER) AS
    v_MaxAppointments NUMBER := NULL;
BEGIN
    -- Clear existing data in MAXAPPOINTMENTPATIENT table for the specified patient
    DELETE FROM MAXAPPOINTMENTPATIENT;

    -- Insert new data based on the maximum appointments for the specified patient
    FOR rec IN (
        SELECT
            P.PATIENT_ID,
            P.FirstName || ' ' || P.LastName AS PATIENTNAME,
            D.FirstName || ' ' || D.LastName AS DOCTORNAME,
            COUNT(A.AppointmentID) AS NUMBEROFAPPOINTMENTS
        FROM
            PATIENT P
        JOIN
            APPOINTMENT A ON P.PATIENT_ID = A.PATIENTID
        JOIN
            DOCTOR D ON A.DOCTORID = D.DOCTORID
        WHERE
            P.PATIENT_ID = p_PatientId
        GROUP BY
            P.PATIENT_ID, P.FirstName, P.LastName, D.FirstName, D.LastName
        ORDER BY
            NUMBEROFAPPOINTMENTS DESC
    ) LOOP
        -- Insert only the rows with the maximum count into MAXAPPOINTMENTPATIENT table
        IF v_MaxAppointments IS NULL OR rec.NUMBEROFAPPOINTMENTS = v_MaxAppointments THEN
            INSERT INTO MAXAPPOINTMENTPATIENT (PATIENTNAME, DOCTORNAME, NUMBEROFAPPOINTMENTS)
            VALUES (rec.PATIENTNAME, rec.DOCTORNAME, rec.NUMBEROFAPPOINTMENTS);
        ELSE
            -- If the count is not equal to the maximum, break the loop
            EXIT;
        END IF;

        -- Update the maximum value after the first iteration
        IF v_MaxAppointments IS NULL THEN
            v_MaxAppointments := rec.NUMBEROFAPPOINTMENTS;
        END IF;
    END LOOP;

    COMMIT;
END FindMaxAppointmentsForPatient;

BEGIN
FindMaxAppointmentsForPatient(1);
END;
SELECT * FROM MAXAPPOINTMENTPATIENT;

--19
--function to verify bills 
CREATE OR REPLACE FUNCTION MAITRO.PAYMENT_VERIFICATION(
    p_appointment_id IN NUMBER,
    p_amount IN NUMBER
) RETURN VARCHAR2 IS
    v_total_cost NUMBER := 0;
    v_message VARCHAR2(100);
BEGIN
    -- Calculate total cost
    SELECT NVL(SUM(COST), 0) + NVL(SUM(DOCTORCOST), 0)
    INTO v_total_cost
    FROM APPOINTMENT A
    JOIN PRESCRIPTION P ON A.APPOINTMENTID = P.APPOINTMENTID
    LEFT JOIN (SELECT PRESCRIPTIONID, SUM(COST) AS COST FROM LABBILL GROUP BY PRESCRIPTIONID) LB ON LB.PRESCRIPTIONID = P.PRESCRIPTIONID
    LEFT JOIN (SELECT PRESCRIPTIONID, SUM(DOCTORCOST) AS DOCTORCOST FROM DOCTORBILL GROUP BY PRESCRIPTIONID) DB ON DB.PRESCRIPTIONID = P.PRESCRIPTIONID
    WHERE A.APPOINTMENTID = p_appointment_id AND P.PRESCRIPTION_STATUS = 'UNPAID';

    IF v_total_cost <= p_amount THEN
        -- Update PRESCRIPTION_STATUS to 'PAID'
        UPDATE PRESCRIPTION
        SET PRESCRIPTION_STATUS = 'PAID'
        WHERE PRESCRIPTION_STATUS = 'UNPAID' AND APPOINTMENTID = p_appointment_id;

        v_message := 'Payment Successful';
    ELSE
        v_message := 'Payment Unsuccessful';
    END IF;

    RETURN v_message;
END PAYMENT_VERIFICATION;


--20
--for password 
-- Create a function to hash the password
CREATE OR REPLACE FUNCTION hash_password(p_password VARCHAR2) RETURN NUMBER IS
  v_hash NUMBER;
BEGIN
  -- Hash the password using ORA_HASH
  v_hash := ORA_HASH(p_password, 2000); -- You can choose your own modulus value

  RETURN v_hash;
END hash_password;
DECLARE
     str NUMBER;
    BEGIN
      SELECT ORA_HASH('test') INTO str FROM dual;
      dbms_output.put_line(str);
    END
		



